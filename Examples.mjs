import runtime from "./Runtime.mjs";
import MutMap from "./MutMap.mjs";
import Predef from "./Predef.mjs";
let Examples1;
(class Examples {
  static {
    Examples1 = Examples;
    let tmp, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6;
    this.examples = MutMap.empty;
    tmp = MutMap.insert("ExampleInResponse.mls", {
    "name": "Example in Response", "source": "\n// * This file contains examples in the author response. A few typos therein are corrected.\n\n\n// Some utility functions:\n\nfun wield: [R] -> (Region[R]) ->{R} ()\nfun freeze: [R, E extends ~R, T] -> (Region[R], () ->{~R & E} T) ->{R | E} T\n// ^ Fixed a typo in the author response (`{~R | E}` should have been `{~R & E}`)\n\nfun (;) seq(_, res) = res\nfun rand: () -> Bool\nfun print: Any -> ()\n\n\n// ### Example 1\n\n\n// Passing the same region for both arguments fundamentally does not work approaches like Rust and Capability Calculus.\nfun foo1(r1, r2) =\n  freeze(r1, () => print(\"ok\"))\n  wield(r2)\n\n// InvalML allows r1 and r2 to alias as long as \u2039body\u203A does not use r2; for instance:\nregion r in\n  foo1(r, r)\n\n// Capability Calculus and related systems would require r2 to be distinct from r1.\n\n// Note \u2013 this also works:\nregion r in\n  region s in\n    foo1(r, s)\n\n// Here is a slightly less trivial examples that still type checks seamlessly in InvalML:\nregion r0 in\n  \n  fun foo1(r1, r2) =\n    freeze(r1, () => wield(r0))\n    wield(r2)\n  \n  region r in\n    foo1(r, r)\n  \n  region r in\n    region s in\n      foo1(r, s)\n\n\n// On the other hand, given\nfun foo2(r1, r2) =\n  freeze(r1, () => wield(r2))\n  wield(r2)\n\n// we rightfully reject\n// region r in\n//   foo2(r, r)\n\n// but still accept\nregion r in\n  region s in\n    foo2(r, s)\n\n\n// ### Example 2\n\n\nfun foo3: [outer, R extends outer] -> Region[R] ->{outer} ()\nfun foo3(r1) =\n  region r2 in\n    freeze(r2, () =>\n      wield(r1)\n    )\n// ^ Fixed typos in the author response (it used the paper's syntax instead of the implementation's syntax)\n\n\n\n// ### Example 3\n\n\nfun foo4(r1, r2, f) =\n  let exec = freeze(r1, () => freeze(r2, () => f(r1, r2)))\n  let r = exec()\n  !r + 1\n\nregion r in\n  region s in\n    foo4(r, s, (x, y) =>\n      if rand() then print(\"Chose x\"); () => x.ref 0\n                else print(\"Chose y\"); () => y.ref 1)\n\n\n// ### Example 4\n\n\nfun foo5(f) =\n  region r in\n    freeze(r, () => f(32))\n\n\nfun freeze2: [R, E extends ~R, T] -> (Region[R], () ->{~R & E} T) ->{R | E} T\n\nfun foo6(f) =\n  region r in\n    freeze(r, () => f(32))\n\nfoo6\n"
    });
    tmp1 = Predef.pipeInto(Examples.examples, tmp);
    tmp2 = MutMap.insert("ExampleInThePaper.mls", {
    "name": "Example in the Paper", "source": "\n// * This file contains examples in the paper\n\nclass ArrayList[A, R]\nclass List[A]\nclass Iter[T, R]\n\nfun mkArrayList : [R, T] -> (Region[R]) ->{R} ArrayList[T, R]\nfun add : [R, T] -> (ArrayList[T, R], T) ->{R} ()\nfun clear : [R, T] -> ArrayList[T, R] ->{R} ()\nfun foreach : [E, R, T] -> (Iter[T, R], T ->{E} ()) -> {R | E} ()\nfun iter : [Res, R, E extends ~R, T] -> (ArrayList[T, R], [I] -> Iter[T, I] ->{I | E} Res) ->{E | R} Res\nfun map: [T, S, E] -> (List[out T], T ->{E} S) ->{E} List[out S]\n\nfun println: Any -> ()\nfun (;) seq(_, res) = res\n\nregion r in // This is used to delimit the scope of mutation\n  let xs = mkArrayList(r) // Creates a new mutable list in r egion r\n  add(xs, \"1\"); add(xs, \"2\"); add(xs, \"3\");\n  iter(xs, it => foreach(it , e => println(e)))\n\n// region r in // This is used to delimit the scope of mutation\n//   let xs = mkArrayList(r) // Creates a new mutable list in r egion r\n//   add(xs, \"1\"); add(xs, \"2\"); add(xs, \"3\");\n//   iter(xs, it => foreach(it , e => println (e); clear (xs)))\n\nfun mapi: [A, B, E] -> (List[out A], (Int, A) ->{E} B) ->{E} List[out B]\nfun mapi(xs, f) =\n  region r in\n    let index = r.ref 0 in map(xs, x => let res = f(!index, x) in index := !index + 1; res)\n\n\nfun f: [R1, R2 extends ~R1] -> (Region[R1], Region[R2]) ->{R1 | R2} Int\n\n\n// region r1 in\n//   let g = (r => region r2 in f(r, r2)) in (region r3 in g(r3))\n\n\nregion r1 in\n  fun g: [outer, R extends outer] -> Region[R] ->{R} Int\n  fun g(r) = region r2 in f(r, r2)\n  region r3 in g(r3)\n\n\nregion r in\n  let a1 = mkArrayList(r) in add(a1, 12); add(a1, 34);\n  iter of a1, it1 =>\n    region s in\n      let a2 = mkArrayList(s)\n      foreach of it1, v1 => add(a2 , v1)\n      iter of a2, it2 => foreach of it2 , v2 => println(v2)\n      clear(a2)\n\n\n// region r in\n//   let a = mkArrayList(r) in add(a, 12); add(a, 34);\n//   iter of a, it =>\n//     foreach of it, v => println(v); clear(a)\n"
    });
    tmp3 = Predef.pipeInto(Examples.examples, tmp2);
    tmp4 = MutMap.insert("MergeSort.mls", {
    "name": "Merge Sort", "source": "\n// *** infrastructures\n\n\ndeclare class Array[T, R]\n\n\nclass Pair[T, S] with\n  constructor\n    Pr(fst: T, snd: S)\n\n\nfun mkArray: [T, R] -> Region[R] ->{R} Array[T, out R]\nfun mkArray(r) = @untyped globalThis.Array()\n\n\nfun push: [T, R] -> (Array[in T, out R], T) ->{R} ()\nfun push(xs, x) = @untyped xs.push(x); ()\n\n\n// push an element to front\nfun unshift: [T, R] -> (Array[in T, out R], T) ->{R} ()\nfun unshift(xs, x) = @untyped xs.unshift(x); ()\n\n\nfun map: [T, S, R, E extends ~R] -> (Array[out T, out R], T ->{E} S) ->{E | R} Array[S, out R]\nfun map(xs, f) = @untyped xs.map(f)\n\n\nfun foreach: [T, R, E extends ~R] -> (Array[out T, out R], T ->{E} ()) ->{E | R} ()\nfun foreach(xs, f) = @untyped xs.forEach(f)\n\n\nfun len: [R] -> Array[in Nothing out Any, out R] ->{R} Int\nfun len(xs) = @untyped xs.length\n\n\nfun at: [T, R] -> (Array[out T, out R], Int) ->{R} T\nfun at(xs, i) = @untyped xs.at(i)\n\n\nfun slice: [T, R] -> (Array[out T, out R], Int) ->{R} Array[out T, out R]\nfun slice(xs, i) = @untyped xs.slice(i)\n\n\nfun concat: [T, R1, R2, R3] -> (Region[R3], Array[in T, out R1], Array[out T, out R2]) ->{R1 | R2 | R3} Array[T, out R3]\nfun concat(r, xs, ys) = @untyped xs.concat(ys)\n\n\nfun freezeArr: [T, R, E extends ~R] -> (Array[in Nothing, out Any], () ->{E} T) ->{E} T\nfun freezeArr(xs, f) = f()\n\n\n// matching on js array is not supported yet.\nfun matchOne(xs, fn, fh) =\n  if len(xs) is 0 then fn(xs)\n  else fh(at(xs, 0), slice(xs, 1))\n\n// fun matchTwo: [T, R, E1, E2, E3, S] -> (Array[out T, out R], Array[out T, out R] ->{E1} S, T ->{E2} S, (T, T, Array[out T, out R]) ->{E3} S) ->{E1 | E2 | E3 | R} S\nfun matchTwo(xs, fn, f1, f2) =\n  if len(xs) is 0 then fn(xs)\n  else if len(xs) is 1 then f1(at(xs, 0))\n  else f2(at(xs, 0), at(xs, 1), slice(xs, 2))\n\n// it should have some primitive effects\n// but we don't support for now\nfun rand: () -> Int\nfun rand() = @untyped globalThis.Math.floor(globalThis.Math.random() * 1000)\n\n\nfun (;) seq(_, res) = res\n\nfun println: Any -> ()\nfun println(x) = @untyped globalThis.console.log(x)\n\n\n// it is not really executed in parallel\n// but it is enough to display the ability of our type system\nfun forkJoin: [T, S, P, E1, E2 extends ~E1, E3] ->\n  (() ->{E1} T, () ->{E2} S, (T, S) ->{E3} P) ->{E1 | E2 | E3} P\nfun forkJoin(f, g, h) =\n  let x = f()\n  let y = g()\n  h(x, y)\n\n\n// *** pmsort implementation\n\n\nfun split(xs, r1, r2) =\n  fun rs(xs, ys, zs) =\n    matchTwo of xs, _ => Pr(ys, zs), x => push(ys, x); Pr(ys, zs), (x1, x2, r) => push(ys, x1); push(zs, x2); rs(r, ys, zs)\n  rs(xs, mkArray(r1), mkArray(r2))\n\n\n// fun merge: [T, R1, R2, R] -> (Array[out T, out R1], Array[out T, out R2], Region[R]) ->{R1 | R2 | R} Array[T, out R]\nfun merge(arr1, arr2, r) =\n  fun recm(xs, ys, acc) =\n    matchOne of xs, _ => concat(r, acc, ys), (x, rx) =>\n      matchOne of ys, _ => concat(r, acc, xs), (y, ry) =>\n        if x < y then push(acc, x); recm(rx, ys, acc)\n        else push(acc, y); recm(xs, ry, acc)\n  recm(arr1, arr2, mkArray(r))\n\n\nfun smsort(xs, r) =\n  matchTwo of xs, _ => mkArray(r), x => let res = mkArray(r) in push(res, x); res, (_, _, _) =>\n    let p = split(xs, r, r) in\n      if p is Pr(fst, snd) then merge(smsort(fst, r), smsort(snd, r), r)\n\n\n// wrong version!\n// fun pmsort: [R1, R2] -> (Array[out Int, out R1], Region[R2]) ->{R1 | R2} Array[Int, out R2]\n// fun pmsort(xs, r) =\n//   matchTwo of xs, _ => mkArray(r), x => let res = mkArray(r) in push(res, x); res, (_, _, _) =>\n//     let p = split(xs, r, r) in\n//       if p is Pr(fst, snd) then\n//         forkJoin(_ => pmsort(fst, r), pmsort(snd, r), (r1, r2) => merge(r1, r2, r))\n\n\nfun pmsort: [R1, R2] -> (Array[out Int, out R1], Region[R2]) ->{R1 | R2} Array[Int, out R2]\nfun pmsort(xs, r) =\n  matchTwo of xs, _ => mkArray(r), x => let res = mkArray(r) in push(res, x); res, (_, _, _) =>\n    region r1 in\n      region r2 in\n        let p = split(xs, r1, r2) in\n          if p is Pr(fst, snd) then\n            forkJoin(() => pmsort(fst, r1), () => pmsort(snd, r2), (rx, ry) => merge(rx, ry, r))\n\n\n// *** simple tests\n\n\nfun randArr(r, n) =\n  if n is 0 then mkArray(r)\n  else\n    let x = rand()\n    let xs = randArr(r, n - 1)\n    push(xs, x)\n    xs\n\n\nregion r in\n  let arr = mkArray(r) // you can try: let arr = randArr(r, 10)\n  push(arr, 10)\n  push(arr, 23)\n  push(arr, 13)\n  push(arr, 4)\n  pmsort(arr, r)\n"
    });
    tmp5 = Predef.pipeInto(Examples.examples, tmp4);
    tmp6 = MutMap.insert("SimpleConstraintSolver.mls", {
    "name": "Simple Constraint Solver", "source": "\n// *** infrastructures\n\nclass PairOf[A, B] with\n  constructor\n    Pair(fst: A, snd: B)\n\nclass Stack[A] with\n  constructor\n    Nil\n    Cons(head: A, tail: Stack[out A])\n\nclass ArrayList[A, R]\nclass Iter[T, R]\n\n\nfun\n  empty:   [A, R] -> Region[R] ->{R} ArrayList[A, out R]\n  clear:   [A, R] -> (ArrayList[A, out R]) ->{R} ()\n  push:    [A, R] -> (ArrayList[A, out R], A) ->{R} ()\n  foreach: [E, R, T] -> (Iter[T, R], T ->{E} ()) ->{R | E} ()\n  iter: [Res, R, E extends ~R, T] ->\n    (ArrayList[T, out R], [S] -> Iter[T, S] ->{S | E} Res) ->{E | R} Res\n  fold: [Res, R, E extends ~R, T] ->\n    (ArrayList[T, out R], Res, [S] -> (Iter[T, S], Res) ->{S | E} Res) ->{E | R} Res\n  read: [T, S] -> Iter[T, S] ->{S} T\n\nfun error() = error()\n\n\n// *** simple constraint solver\n\n\nclass Type[R] with\n  constructor\n    IntType\n    Unif(id: Int, lowerBounds: ArrayList[Type[R], out R], upperBounds: ArrayList[Type[R], out R])\n    Fun(lhs: Type[R], rhs: Type[R])\n\n\nfun solve(lst) = if lst is\n  Nil then ()\n  Cons(c, cs) then if c is\n    Pair(lhs, rhs) then\n      if lhs is\n        IntType then if rhs is\n          IntType then ()\n          Fun(_, _) then error()\n          Unif(id, lbs, ubs) then\n            push(lbs, lhs)\n            let ncs = fold(ubs, cs, (it, lst) => Cons(Pair(lhs, read(it)), lst))\n            solve(ncs)\n        Fun(l1, r1) then if rhs is\n          Fun(l2, r2) then\n            solve(Cons(Pair(l2, l1), Cons(Pair(r1, r2), cs)))\n          IntType then error()\n          Unif(id, lbs, ubs) then\n            push(lbs, lhs)\n            let ncs = fold(ubs, cs, (it, lst) => Cons(Pair(lhs, read(it)), lst))\n            solve(ncs)\n        Unif(id, lbs, ubs) then\n          push(ubs, rhs)\n          let ncs = fold(lbs, cs, (it, lst) => Cons(Pair(read(it), rhs), lst))\n          solve(ncs)\n\n\n\n// *** examples\n\nregion r in\n  solve(Cons(Pair(IntType, IntType), Nil))\n\n\n\nregion r in\n  solve(Cons(Pair(IntType, Fun(IntType, IntType)), Nil))\n\n\nregion r in\n  let v1 = Unif(1, empty(r), empty(r))\n  let v2 = Unif(2, empty(r), empty(r))\n  solve(Cons(Pair(v1, Fun(IntType, v2)), Nil))\n"
    });
    Predef.pipeInto(Examples.examples, tmp6)
  }
  static toString() { return "Examples"; }
});
let Examples = Examples1; export default Examples;
